# EPAM University Programs

## DevOps education program
### Module 5 Linux Essentials


#### TASK 1

##### Part1
1) Log in to the system as root.
```sh
ssh root@192.168.0.9
```

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/0.jpg)

2) Use the passwd command to change the password. Examine the basic
parameters of the command. What system file does it change *?

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/1.jpg)

```sh
[root@localhost ~]# passwd --help
Usage: passwd [OPTION...] <accountName>
  -k, --keep-tokens       keep non-expired authentication tokens
  -d, --delete            delete the password for the named account (root
                          only); also removes password lock if any
  -l, --lock              lock the password for the named account (root only)
  -u, --unlock            unlock the password for the named account (root only)
  -e, --expire            expire the password for the named account (root only)
  -f, --force             force operation
  -x, --maximum=DAYS      maximum password lifetime (root only)
  -n, --minimum=DAYS      minimum password lifetime (root only)
  -w, --warning=DAYS      number of days warning users receives before
                          password expiration (root only)
  -i, --inactive=DAYS     number of days after password expiration when an
                          account becomes disabled (root only)
  -S, --status            report password status on the named account (root
                          only)
      --stdin             read new tokens from stdin (root only)
Help options:
  -?, --help              Show this help message
      --usage             Display brief usage message
```

After changing the password using ```passwd``` command, hashes in file ```/etc/shadow``` had rewritten.

3) Determine the users registered in the system, as well as what commands they
execute. What additional information can be gleaned from the command
execution?
Output of ```who, w, whoami,id```:

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/2.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/3.jpg)

I cauld to use vipw command

I don't have command execution on my CentOS. If you mean ```exec``` command than we can Replace the shell with the given command.
The exec() family of functions replaces the current process image with a new process image. The initial argument for these functions is the name of a file that is to be executed. The functions can be grouped based on the letters following the "exec" prefix.

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/49.jpg)

4) Change personal information about yourself.
 
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/4.jpg)
 
5) Become familiar with the Linux help system and the man and info commands.
Get help on the previously discussed commands, define and describe any two
keys for these commands. Give examples.

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/8.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/7.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/6.jpg)

Or command - ```whatis```

6) Explore the more and less commands using the help system. View the contents
of files .bash* using commands.

more - view the file
less - view file (+ arrows + search) (important for big files bcz command is using cache!)

```sh
# bash/zsh git prompt support
#
# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>
# Distributed under the GNU General Public License, version 2.0.
#
# This script allows you to see repository status in your prompt.
#
# To enable:
#
#    1) Copy this file to somewhere (e.g. ~/.git-prompt.sh).
#    2) Add the following line to your .bashrc/.zshrc:
#        source ~/.git-prompt.sh
#    3a) Change your PS1 to call __git_ps1 as
#        command-substitution:
#        Bash: PS1='[\u@\h \W$(__git_ps1 " (%s)")]\$ '
#        ZSH:  setopt PROMPT_SUBST ; PS1='[%n@%m %c$(__git_ps1 " (%s)")]\$ '
#        the optional argument will be used as format string.
#    3b) Alternatively, for a slightly faster prompt, __git_ps1 can
#        be used for PROMPT_COMMAND in Bash or for precmd() in Zsh
#        with two parameters, <pre> and <post>, which are strings
#        you would put in $PS1 before and after the status string
#        generated by the git-prompt machinery.  e.g.
#        Bash: PROMPT_COMMAND='__git_ps1 "\u@\h:\w" "\\\$ "'
#          will show username, at-sign, host, colon, cwd, then
#          various status string, followed by dollar and SP, as
#          your prompt.
#        ZSH:  precmd () { __git_ps1 "%n" ":%~$ " "|%s" }
#          will show username, pipe, then various status string,
#          followed by colon, cwd, dollar and SP, as your prompt.
#        Optionally, you can supply a third argument with a printf
#        format string to finetune the output of the branch status
#
# The repository status will be displayed only if you are currently in a
# git repository. The %s token is the placeholder for the shown status.
#
# The prompt status always includes the current branch name.
#
# In addition, if you set GIT_PS1_SHOWDIRTYSTATE to a nonempty value,
# unstaged (*) and staged (+) changes will be shown next to the branch
# name.  You can configure this per-repository with the
# bash.showDirtyState variable, which defaults to true once
# GIT_PS1_SHOWDIRTYSTATE is enabled.
#
# You can also see if currently something is stashed, by setting
# GIT_PS1_SHOWSTASHSTATE to a nonempty value. If something is stashed,
# then a '$' will be shown next to the branch name.
#
# If you would like to see if there're untracked files, then you can set
# GIT_PS1_SHOWUNTRACKEDFILES to a nonempty value. If there're untracked
# files, then a '%' will be shown next to the branch name.  You can
# configure this per-repository with the bash.showUntrackedFiles
# variable, which defaults to true once GIT_PS1_SHOWUNTRACKEDFILES is
# enabled.
#
# If you would like to see the difference between HEAD and its upstream,
# set GIT_PS1_SHOWUPSTREAM="auto".  A "<" indicates you are behind, ">"
# indicates you are ahead, "<>" indicates you have diverged and "="
# indicates that there is no difference. You can further control
# behaviour by setting GIT_PS1_SHOWUPSTREAM to a space-separated list
# of values:
#
#     verbose       show number of commits ahead/behind (+/-) upstream
#     name          if verbose, then also show the upstream abbrev name
#     legacy        don't use the '--count' option available in recent
#                   versions of git-rev-list
#     git           always compare HEAD to @{upstream}
#     svn           always compare HEAD to your SVN upstream
#
# You can change the separator between the branch name and the above
# state symbols by setting GIT_PS1_STATESEPARATOR. The default separator
# is SP.
#
# When there is an in-progress operation such as a merge, rebase,
# revert, cherry-pick, or bisect, the prompt will include information
# related to the operation, often in the form "|<OPERATION-NAME>".
#
# When the repository has a sparse-checkout, a notification of the form
# "|SPARSE" will be included in the prompt.  This can be shortened to a
# single '?' character by setting GIT_PS1_COMPRESSSPARSESTATE, or omitted
# by setting GIT_PS1_OMITSPARSESTATE.
#
# By default, __git_ps1 will compare HEAD to your SVN upstream if it can
# find one, or @{upstream} otherwise.  Once you have set
# GIT_PS1_SHOWUPSTREAM, you can override it on a per-repository basis by
# setting the bash.showUpstream config variable.
#
# If you would like to see more information about the identity of
# commits checked out as a detached HEAD, set GIT_PS1_DESCRIBE_STYLE
# to one of these values:
#
#     contains      relative to newer annotated tag (v1.6.3.2~35)
#     branch        relative to newer tag or branch (master~4)
#     describe      relative to older annotated tag (v1.6.3.1-13-gdd42c2f)
#     tag           relative to any older tag (v1.6.3.1-13-gdd42c2f)
#     default       exactly matching tag
#
# If you would like a colored hint about the current dirty state, set
# GIT_PS1_SHOWCOLORHINTS to a nonempty value. The colors are based on
# the colored output of "git status -sb" and are available only when
# using __git_ps1 for PROMPT_COMMAND or precmd in Bash,
# but always available in Zsh.
#
# If you would like __git_ps1 to do nothing in the case when the current
# directory is set up to be ignored by git, then set
# GIT_PS1_HIDE_IF_PWD_IGNORED to a nonempty value. Override this on the
# repository level by setting bash.hideIfPwdIgnored to "false".

# check whether printf supports -v
__git_printf_supports_v=
printf -v __git_printf_supports_v -- '%s' yes >/dev/null 2>&1

# stores the divergence from upstream in $p
# used by GIT_PS1_SHOWUPSTREAM
__git_ps1_show_upstream ()
{
	local key value
	local svn_remote svn_url_pattern count n
	local upstream=git legacy="" verbose="" name=""

	svn_remote=()
	# get some config options from git-config
	local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')"
	while read -r key value; do
		case "$key" in
		bash.showupstream)
			GIT_PS1_SHOWUPSTREAM="$value"
			if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
				p=""
				return
			fi
			;;
		svn-remote.*.url)
			svn_remote[$((${#svn_remote[@]} + 1))]="$value"
			svn_url_pattern="$svn_url_pattern\\|$value"
			upstream=svn+git # default upstream is SVN if available, else git
			;;
		esac
	done <<< "$output"

	# parse configuration values
	for option in ${GIT_PS1_SHOWUPSTREAM}; do
		case "$option" in
		git|svn) upstream="$option" ;;
		verbose) verbose=1 ;;
		legacy)  legacy=1  ;;
		name)    name=1 ;;
		esac
	done

	# Find our upstream
	case "$upstream" in
	git)    upstream="@{upstream}" ;;
	svn*)
		# get the upstream from the "git-svn-id: ..." in a commit message
		# (git-svn uses essentially the same procedure internally)
		local -a svn_upstream
		svn_upstream=($(git log --first-parent -1 \
					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null))
		if [[ 0 -ne ${#svn_upstream[@]} ]]; then
			svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]}
			svn_upstream=${svn_upstream%@*}
			local n_stop="${#svn_remote[@]}"
			for ((n=1; n <= n_stop; n++)); do
				svn_upstream=${svn_upstream#${svn_remote[$n]}}
			done

			if [[ -z "$svn_upstream" ]]; then
				# default branch name for checkouts with no layout:
				upstream=${GIT_SVN_ID:-git-svn}
			else
				upstream=${svn_upstream#/}
			fi
		elif [[ "svn+git" = "$upstream" ]]; then
			upstream="@{upstream}"
		fi
		;;
	esac

	# Find how many commits we are ahead/behind our upstream
	if [[ -z "$legacy" ]]; then
		count="$(git rev-list --count --left-right \
				"$upstream"...HEAD 2>/dev/null)"
	else
		# produce equivalent output to --count for older versions of git
		local commits
		if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"
		then
			local commit behind=0 ahead=0
			for commit in $commits
			do
				case "$commit" in
				"<"*) ((behind++)) ;;
				*)    ((ahead++))  ;;
				esac
			done
			count="$behind	$ahead"
		else
			count=""
		fi
	fi

	# calculate the result
	if [[ -z "$verbose" ]]; then
		case "$count" in
		"") # no upstream
			p="" ;;
		"0	0") # equal to upstream
			p="=" ;;
		"0	"*) # ahead of upstream
			p=">" ;;
		*"	0") # behind upstream
			p="<" ;;
		*)	    # diverged from upstream
			p="<>" ;;
		esac
	else
		case "$count" in
		"") # no upstream
			p="" ;;
		"0	0") # equal to upstream
			p=" u=" ;;
		"0	"*) # ahead of upstream
			p=" u+${count#0	}" ;;
		*"	0") # behind upstream
			p=" u-${count%	0}" ;;
		*)	    # diverged from upstream
			p=" u+${count#*	}-${count%	*}" ;;
		esac
		if [[ -n "$count" && -n "$name" ]]; then
			__git_ps1_upstream_name=$(git rev-parse \
				--abbrev-ref "$upstream" 2>/dev/null)
			if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
				p="$p \${__git_ps1_upstream_name}"
			else
				p="$p ${__git_ps1_upstream_name}"
				# not needed anymore; keep user's
				# environment clean
				unset __git_ps1_upstream_name
			fi
		fi
	fi

}

# Helper function that is meant to be called from __git_ps1.  It
# injects color codes into the appropriate gitstring variables used
# to build a gitstring.
__git_ps1_colorize_gitstring ()
{
	if [[ -n ${ZSH_VERSION-} ]]; then
		local c_red='%F{red}'
		local c_green='%F{green}'
		local c_lblue='%F{blue}'
		local c_clear='%f'
	else
		# Using \[ and \] around colors is necessary to prevent
		# issues with command line editing/browsing/completion!
		local c_red='\[\e[31m\]'
		local c_green='\[\e[32m\]'
		local c_lblue='\[\e[1;34m\]'
		local c_clear='\[\e[0m\]'
	fi
	local bad_color=$c_red
	local ok_color=$c_green
	local flags_color="$c_lblue"

	local branch_color=""
	if [ $detached = no ]; then
		branch_color="$ok_color"
	else
		branch_color="$bad_color"
	fi
	c="$branch_color$c"

	z="$c_clear$z"
	if [ "$w" = "*" ]; then
		w="$bad_color$w"
	fi
	if [ -n "$i" ]; then
		i="$ok_color$i"
	fi
	if [ -n "$s" ]; then
		s="$flags_color$s"
	fi
	if [ -n "$u" ]; then
		u="$bad_color$u"
	fi
	r="$c_clear$r"
}

# Helper function to read the first line of a file into a variable.
# __git_eread requires 2 arguments, the file pa
```

7) *Describe in plans that you are working on laboratory work 1. Tip: You should
read the documentation for the finger command.

I was using CentOS. The last version of CentOs doesn't have ```finger``` command, the alternative command is ```pinky```

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/9.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/10.jpg)

8) *List the contents of the home directory using the ls command, define its files
and directories. Hint: Use the help system to familiarize yourself with the ls
command.

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/11.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/12.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/13.jpg)

* 1st column 
permission
* 2nd column
This tells us about how many link to this file
* 3rd column
This tells us about who is the owner of the file/directory
* 4th column
This tells us about who the group owner of the file/directory
* 5th column
This tells us about the size of the file/directory in bytes unit. Except for directories, the size will always count as 4096 bytes
* 6th column
This tells us about the last time and date the file is modified
* 7th column
This tells us the filename or directory name

ls - list directory contents
ls -l / - show content of root directory using long listing format
ls ~ - show content of home folder
ls -a - show ALL, do not ignore entries starting with dot
ls -la - combine of ALL and long listing format
ls -lda ~ - adds -d flag : list directory entries instead of contents

***

##### Part2


1) Examine the tree command. Master the technique of applying a template, for
example, display all files that contain a character c, or files that contain a
specific sequence of characters. List subdirectories of the root directory up to
and including the second nesting level.

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/20.jpg)

To list the directory contents with the full path prefix for each sub-directory and file, i used the -f as shown.

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/21.jpg)

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/23.jpg)

I specified the maximum display depth of the directory tree using the -L option. For example, a depth of 2

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/22.jpg)



![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/25.jpg)

To display only those files that match the wild-card pattern I used the -P flag and specify your pattern.  The command will only list files that match c*
```tree -P [[pattern]*]/[*[pattern]]/[[*pattern*]]```

I can also use the tree command to list everything but the files containing a specific wild card pattern.
Do not list those files that match the wild-card pattern.

```tree -I *[keywords]```

I  prune empty directories from the output by adding the --prune option
There are also some useful file options supported by tree such as -p which prints the file type and permissions for each file in a similar way as the ls -l

List subdirectories of the root directory up to
and including the second nesting level.

```tree -d -L 1```

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/24.jpg)

2) What command can be used to determine the type of file (for example, text or
binary)? Give an example.

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/26.jpg)
Command ```file```

3) Master the skills of navigating the file system using relative and absolute paths.
How can you go back to your home directory from anywhere in the filesystem?

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/27.jpg) 

``` sh
cd /var/log
cd /run/app
cd /etc/sound/events

#root folder
cd /  
# change directory to 1/2 level up on directory system
cd ..
cd .
cd ../
#home directory
cd $HOME
cd ~ 

#pwd - present working directory
```
etc.

4) Become familiar with the various options for the ls command. Give examples
of listing directories using different keys. Explain the information displayed on
the terminal using the -l and -a switches.

> See Part 1 exercises #8

5) Perform the following sequence of operations:
- create a subdirectory in the home directory;
- in this subdirectory create a file containing information about directories
located in the root directory (using I/O redirection operations);
- view the created file;
- copy the created file to your home directory using relative and absolute
addressing.
- delete the previously created subdirectory with the file requesting removal;
- delete the file copied to the home directory.

```sh
#! /bin/bash
cd /home/main/
mkdir alex
tree -d -L 1 / > ./alex/volchenko.txt
cat ./alex/volchenko.txt
cp /home/main/alex/volchenko.txt /home/main/
ls /home/main/
rm -ri /home/main/alex/
rm -rf /home/main/volcheko.txt
```

6) Perform the following sequence of operations:
- create a subdirectory test in the home directory;
- copy the .bash_history file to this directory while changing its name to labwork2;
- create a hard and soft link to the labwork2 file in the test subdirectory;
- how to define soft and hard link, what do these
concepts;
- change the data by opening a symbolic link. What changes will happen and
why
- rename the hard link file to hard_lnk_labwork2;
- rename the soft link file to symb_lnk_labwork2 file;
- then delete the labwork2. What changes have occurred and why?

```sh
#! /bin/bash
df
mkdir /home/main/test
cp $HOME/.bash_history /home/main/test/labwork2
cd /home/main/test
#created hardlink
ln -s labwork2 symb_lnk_labwork2
ln labwork2 hard_lnk_labwork2
#checking links 
ls -lia
df -i
rm -rf labwork2
file labwork2
cat labwork2
```
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/28.jpg)
A symbolic or soft link is an actual link to the original file, whereas a hard link is a mirror copy of the original file. If delete the original file, the soft link has no value, because it points to a non-existent file. But in the case of hard link, it is entirely opposite. Even if delete the original file, the hard link will still has the data of the original file. Because hard link acts as a mirror copy of the original file.

screen

7) Using the locate utility, find all files that contain the squid and traceroute
sequence.

```updatedb``` - update filebase

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/29.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/30.jpg)

8) Determine which partitions are mounted in the system, as well as the types of
these partitions.

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/31.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/32.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/33.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/34.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/35.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/36.jpg)

```cfdicsk```

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/37.jpg)

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/38.jpg)

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/39.jpg)

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/47.jpg)

9) Count the number of lines containing a given sequence of characters in a given
file.

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/40.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/41.jpg)

10) Using the find command, find all files in the /etc directory containing the
host character sequence.

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/42.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/43.jpg)

11) List all objects in /etc that contain the ss character sequence. How can I
duplicate a similar command using a bunch of grep?

```sh 
cd /etc 
grep ss * && !!
```
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/44.jpg)

* Search across multiple files
> This's command finds inside and outside the file. It's interesting and I think I must write here.

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/45.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/46.jpg)

12) Organize a screen-by-screen print of the contents of the /etc directory. Hint:
You must use stream redirection operations.

```ls -la /etc | less > /dev/pts/0```

```ls -a /etc | less > /dev/pts/0```

```dir /etc | less > /dev/pts/0```

13) What are the types of devices and how to determine the type of device? Give
examples.

EXAMPLES:
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/47.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/48.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/50.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/51.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/52.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/53.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/54.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/55.jpg)

The ones that have a "b" are block type devices and the ones that begin with "c" are character devices.
p - pipe
s - socket

See above in Part2

Common SCSI device files:

/dev/sda - First hard disk
/dev/sdb - Second hard disk
/dev/sda3 - Third partition on the first hard disk
Pseudo Devices

As we discussed earlier, pseudo devices aren't really physically connected to your system, most common pseudo devices are character devices:

/dev/zero - accepts and discards all input, produces a continuous stream of NULL (zero value) bytes
/dev/null - accepts and discards all input, produces no output
/dev/random - produces random numbers
/dev/pts -  "display" accepts and output

Pseudo & Terminals
/dev/tty - virtual console
/dev/pty pseudo terminals


PATA Devices
Sometimes in older systems you may see hard drives being referred to with an hd prefix:

/dev/hda - First hard disk
/dev/hdd2 - Second partition on 4th hard disk

[https://www.debian.org/releases/wheezy/amd64/apds01.html.en](https://www.debian.org/releases/wheezy/amd64/apds01.html.en)

14) How to determine the type of file in the system, what types of files are there?

> See last 2 screens^

You can use ```ls -l``` command for this operation.

Regular file - Regular files show up with a hyphen-minus ```-```
Directory - `d`
Symbolic link - `l`
FIFO (named pipe) - `p` - connect the output of one process to the input of another
Socket - `s` - A socket is a special file used for inter-process communication, which enables communication between two processes. In addition to sending data, processes can send file descriptors
Device file (block, character) - See above

15) * List the first 5 directory files that were recently accessed in the /etc
directory.

![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/56.jpg)
![Image](https://github.com/Twicer/DevOps_online_Dnipro_2020Q42021Q1/tree/master/m5/task5.1/screens/57.jpg)


>> This is what I found on unix.stackexchnage.com . I think It's interesting and I leave here for myself

To print the last 3 accessed files (sorted from the last accessed file to the third last accessed file):

```find . -type f -exec stat -c '%X %n' {} \; | sort -nr | awk 'NR==1,NR==3 {print $2}'```

To print the last 3 modified files (sorted from the last modified file to the third last modified file):

```find . -type f -exec stat -c '%Y %n' {} \; | sort -nr | awk 'NR==1,NR==3 {print $2}'
find . -type f -exec stat -c '%X %n' *: prints the last access' time followed by the file's path for each file in the current directory hierarchy;
find . -type f -exec stat -c '%Y %n' *: prints the last modification's time followed by the file's path for each file in the current directory hierarchy;
sort -nr: sorts in an inverse numerical order;
awk 'NR==1,NR==3 {print $2}': prints the second field of the first, second and third line.
```

You can change the number of files to be shown by changing 3 to the desired number of files in ```awk 'NR==1,NR==3 {print $2}'```.
